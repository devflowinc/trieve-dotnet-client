/*
 * Trieve API
 *
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: developers@trieve.ai
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using trieve_dotnet_client.Client;
using trieve_dotnet_client.Model;

namespace trieve_dotnet_client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessageApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create a message
        /// </summary>
        /// <remarks>
        /// Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string CreateMessageCompletionHandler(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0);

        /// <summary>
        /// Create a message
        /// </summary>
        /// <remarks>
        /// Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> CreateMessageCompletionHandlerWithHttpInfo(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0);
        /// <summary>
        /// Edit a message
        /// </summary>
        /// <remarks>
        /// Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void EditMessageHandler(string tRDataset, EditMessageData editMessageData, int operationIndex = 0);

        /// <summary>
        /// Edit a message
        /// </summary>
        /// <remarks>
        /// Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> EditMessageHandlerWithHttpInfo(string tRDataset, EditMessageData editMessageData, int operationIndex = 0);
        /// <summary>
        /// Get all messages for a given topic
        /// </summary>
        /// <remarks>
        /// Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Message&gt;</returns>
        List<Message> GetAllTopicMessages(string tRDataset, Guid messagesTopicId, int operationIndex = 0);

        /// <summary>
        /// Get all messages for a given topic
        /// </summary>
        /// <remarks>
        /// Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Message&gt;</returns>
        ApiResponse<List<Message>> GetAllTopicMessagesWithHttpInfo(string tRDataset, Guid messagesTopicId, int operationIndex = 0);
        /// <summary>
        /// Regenerate message
        /// </summary>
        /// <remarks>
        /// Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string RegenerateMessageHandler(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0);

        /// <summary>
        /// Regenerate message
        /// </summary>
        /// <remarks>
        /// Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> RegenerateMessageHandlerWithHttpInfo(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessageApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Create a message
        /// </summary>
        /// <remarks>
        /// Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> CreateMessageCompletionHandlerAsync(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a message
        /// </summary>
        /// <remarks>
        /// Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> CreateMessageCompletionHandlerWithHttpInfoAsync(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a message
        /// </summary>
        /// <remarks>
        /// Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task EditMessageHandlerAsync(string tRDataset, EditMessageData editMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a message
        /// </summary>
        /// <remarks>
        /// Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> EditMessageHandlerWithHttpInfoAsync(string tRDataset, EditMessageData editMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all messages for a given topic
        /// </summary>
        /// <remarks>
        /// Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Message&gt;</returns>
        System.Threading.Tasks.Task<List<Message>> GetAllTopicMessagesAsync(string tRDataset, Guid messagesTopicId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get all messages for a given topic
        /// </summary>
        /// <remarks>
        /// Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Message&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Message>>> GetAllTopicMessagesWithHttpInfoAsync(string tRDataset, Guid messagesTopicId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Regenerate message
        /// </summary>
        /// <remarks>
        /// Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> RegenerateMessageHandlerAsync(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Regenerate message
        /// </summary>
        /// <remarks>
        /// Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </remarks>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> RegenerateMessageHandlerWithHttpInfoAsync(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessageApi : IMessageApiSync, IMessageApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MessageApi : IMessageApi
    {
        private trieve_dotnet_client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MessageApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MessageApi(string basePath)
        {
            this.Configuration = trieve_dotnet_client.Client.Configuration.MergeConfigurations(
                trieve_dotnet_client.Client.GlobalConfiguration.Instance,
                new trieve_dotnet_client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new trieve_dotnet_client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new trieve_dotnet_client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = trieve_dotnet_client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public MessageApi(trieve_dotnet_client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = trieve_dotnet_client.Client.Configuration.MergeConfigurations(
                trieve_dotnet_client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new trieve_dotnet_client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new trieve_dotnet_client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = trieve_dotnet_client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public MessageApi(trieve_dotnet_client.Client.ISynchronousClient client, trieve_dotnet_client.Client.IAsynchronousClient asyncClient, trieve_dotnet_client.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = trieve_dotnet_client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public trieve_dotnet_client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public trieve_dotnet_client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public trieve_dotnet_client.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public trieve_dotnet_client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Create a message Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string CreateMessageCompletionHandler(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0)
        {
            trieve_dotnet_client.Client.ApiResponse<string> localVarResponse = CreateMessageCompletionHandlerWithHttpInfo(tRDataset, createMessageData);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a message Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public trieve_dotnet_client.Client.ApiResponse<string> CreateMessageCompletionHandlerWithHttpInfo(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0)
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->CreateMessageCompletionHandler");
            }

            // verify the required parameter 'createMessageData' is set
            if (createMessageData == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'createMessageData' when calling MessageApi->CreateMessageCompletionHandler");
            }

            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter
            localVarRequestOptions.Data = createMessageData;

            localVarRequestOptions.Operation = "MessageApi.CreateMessageCompletionHandler";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<string>("/api/message", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMessageCompletionHandler", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a message Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> CreateMessageCompletionHandlerAsync(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            trieve_dotnet_client.Client.ApiResponse<string> localVarResponse = await CreateMessageCompletionHandlerWithHttpInfoAsync(tRDataset, createMessageData, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a message Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="createMessageData">JSON request payload to create a message completion</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<trieve_dotnet_client.Client.ApiResponse<string>> CreateMessageCompletionHandlerWithHttpInfoAsync(string tRDataset, CreateMessageData createMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->CreateMessageCompletionHandler");
            }

            // verify the required parameter 'createMessageData' is set
            if (createMessageData == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'createMessageData' when calling MessageApi->CreateMessageCompletionHandler");
            }


            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter
            localVarRequestOptions.Data = createMessageData;

            localVarRequestOptions.Operation = "MessageApi.CreateMessageCompletionHandler";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/api/message", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMessageCompletionHandler", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a message Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void EditMessageHandler(string tRDataset, EditMessageData editMessageData, int operationIndex = 0)
        {
            EditMessageHandlerWithHttpInfo(tRDataset, editMessageData);
        }

        /// <summary>
        /// Edit a message Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public trieve_dotnet_client.Client.ApiResponse<Object> EditMessageHandlerWithHttpInfo(string tRDataset, EditMessageData editMessageData, int operationIndex = 0)
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->EditMessageHandler");
            }

            // verify the required parameter 'editMessageData' is set
            if (editMessageData == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'editMessageData' when calling MessageApi->EditMessageHandler");
            }

            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter
            localVarRequestOptions.Data = editMessageData;

            localVarRequestOptions.Operation = "MessageApi.EditMessageHandler";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/api/message", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("EditMessageHandler", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a message Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task EditMessageHandlerAsync(string tRDataset, EditMessageData editMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await EditMessageHandlerWithHttpInfoAsync(tRDataset, editMessageData, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Edit a message Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="editMessageData">JSON request payload to edit a message and get a new stream</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<trieve_dotnet_client.Client.ApiResponse<Object>> EditMessageHandlerWithHttpInfoAsync(string tRDataset, EditMessageData editMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->EditMessageHandler");
            }

            // verify the required parameter 'editMessageData' is set
            if (editMessageData == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'editMessageData' when calling MessageApi->EditMessageHandler");
            }


            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter
            localVarRequestOptions.Data = editMessageData;

            localVarRequestOptions.Operation = "MessageApi.EditMessageHandler";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/api/message", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("EditMessageHandler", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all messages for a given topic Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Message&gt;</returns>
        public List<Message> GetAllTopicMessages(string tRDataset, Guid messagesTopicId, int operationIndex = 0)
        {
            trieve_dotnet_client.Client.ApiResponse<List<Message>> localVarResponse = GetAllTopicMessagesWithHttpInfo(tRDataset, messagesTopicId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all messages for a given topic Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Message&gt;</returns>
        public trieve_dotnet_client.Client.ApiResponse<List<Message>> GetAllTopicMessagesWithHttpInfo(string tRDataset, Guid messagesTopicId, int operationIndex = 0)
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->GetAllTopicMessages");
            }

            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("messages_topic_id", trieve_dotnet_client.Client.ClientUtils.ParameterToString(messagesTopicId)); // path parameter
            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter

            localVarRequestOptions.Operation = "MessageApi.GetAllTopicMessages";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Message>>("/api/messages/{messages_topic_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllTopicMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all messages for a given topic Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Message&gt;</returns>
        public async System.Threading.Tasks.Task<List<Message>> GetAllTopicMessagesAsync(string tRDataset, Guid messagesTopicId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            trieve_dotnet_client.Client.ApiResponse<List<Message>> localVarResponse = await GetAllTopicMessagesWithHttpInfoAsync(tRDataset, messagesTopicId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all messages for a given topic Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="messagesTopicId">The ID of the topic to get messages for.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Message&gt;)</returns>
        public async System.Threading.Tasks.Task<trieve_dotnet_client.Client.ApiResponse<List<Message>>> GetAllTopicMessagesWithHttpInfoAsync(string tRDataset, Guid messagesTopicId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->GetAllTopicMessages");
            }


            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("messages_topic_id", trieve_dotnet_client.Client.ClientUtils.ParameterToString(messagesTopicId)); // path parameter
            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter

            localVarRequestOptions.Operation = "MessageApi.GetAllTopicMessages";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Message>>("/api/messages/{messages_topic_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllTopicMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Regenerate message Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string RegenerateMessageHandler(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0)
        {
            trieve_dotnet_client.Client.ApiResponse<string> localVarResponse = RegenerateMessageHandlerWithHttpInfo(tRDataset, regenerateMessageData);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Regenerate message Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public trieve_dotnet_client.Client.ApiResponse<string> RegenerateMessageHandlerWithHttpInfo(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0)
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->RegenerateMessageHandler");
            }

            // verify the required parameter 'regenerateMessageData' is set
            if (regenerateMessageData == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'regenerateMessageData' when calling MessageApi->RegenerateMessageHandler");
            }

            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter
            localVarRequestOptions.Data = regenerateMessageData;

            localVarRequestOptions.Operation = "MessageApi.RegenerateMessageHandler";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<string>("/api/message", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RegenerateMessageHandler", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Regenerate message Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> RegenerateMessageHandlerAsync(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            trieve_dotnet_client.Client.ApiResponse<string> localVarResponse = await RegenerateMessageHandlerWithHttpInfoAsync(tRDataset, regenerateMessageData, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Regenerate message Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
        /// </summary>
        /// <exception cref="trieve_dotnet_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tRDataset">The dataset id to use for the request</param>
        /// <param name="regenerateMessageData">JSON request payload to delete an agent message then regenerate it in a strem</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<trieve_dotnet_client.Client.ApiResponse<string>> RegenerateMessageHandlerWithHttpInfoAsync(string tRDataset, RegenerateMessageData regenerateMessageData, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'tRDataset' is set
            if (tRDataset == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'tRDataset' when calling MessageApi->RegenerateMessageHandler");
            }

            // verify the required parameter 'regenerateMessageData' is set
            if (regenerateMessageData == null)
            {
                throw new trieve_dotnet_client.Client.ApiException(400, "Missing required parameter 'regenerateMessageData' when calling MessageApi->RegenerateMessageHandler");
            }


            trieve_dotnet_client.Client.RequestOptions localVarRequestOptions = new trieve_dotnet_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json"
            };

            var localVarContentType = trieve_dotnet_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = trieve_dotnet_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.HeaderParameters.Add("TR-Dataset", trieve_dotnet_client.Client.ClientUtils.ParameterToString(tRDataset)); // header parameter
            localVarRequestOptions.Data = regenerateMessageData;

            localVarRequestOptions.Operation = "MessageApi.RegenerateMessageHandler";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<string>("/api/message", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RegenerateMessageHandler", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
